<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Xardent Office Simulator - Happy Vibes Edition</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        background: #000;
      }

      #canvas-container {
        width: 100vw;
        height: 100vh;
        position: relative;
      }

      #ui-overlay {
        position: absolute;
        top: 20px;
        left: 20px;
        color: white;
        background: rgba(0, 0, 0, 0.7);
        padding: 15px;
        border-radius: 10px;
        backdrop-filter: blur(10px);
        max-width: 300px;
      }

      #dialogue-box {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(255, 255, 255, 0.95);
        color: #333;
        padding: 20px;
        border-radius: 15px;
        max-width: 600px;
        width: 90%;
        display: none;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(20px);
      }

      #dialogue-box h3 {
        margin: 0 0 10px 0;
        color: #d97356;
      }

      #dialogue-content {
        margin: 10px 0;
        line-height: 1.6;
        max-height: 200px;
        overflow-y: auto;
      }

      .dialogue-option {
        background: #f0f0f0;
        border: 2px solid #d97356;
        padding: 12px;
        margin: 8px 0;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s;
      }

      .dialogue-option:hover {
        background: #d97356;
        color: white;
        transform: translateX(5px);
      }

      #custom-question-container {
        margin-top: 15px;
        padding-top: 15px;
        border-top: 1px solid #ddd;
      }

      #custom-question-input {
        width: 100%;
        padding: 10px;
        border: 2px solid #d97356;
        border-radius: 8px;
        font-size: 14px;
        font-family: inherit;
        box-sizing: border-box;
      }

      #custom-question-submit {
        background: #d97356;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 8px;
        margin-top: 8px;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.3s;
      }

      #custom-question-submit:hover {
        background: #c85a3f;
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      }

      #custom-question-submit:disabled {
        background: #999;
        cursor: not-allowed;
        transform: none;
      }

      .loading {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid rgba(217, 115, 86, 0.3);
        border-radius: 50%;
        border-top-color: #d97356;
        animation: spin 1s ease-in-out infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .instruction {
        opacity: 0.8;
        font-size: 14px;
        margin-top: 10px;
      }

      #interaction-prompt {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 10px 20px;
        border-radius: 20px;
        display: none;
        font-size: 14px;
      }

      .floating-text {
        position: absolute;
        color: #ff0;
        font-size: 24px;
        font-weight: bold;
        pointer-events: none;
        animation: floatUp 2s ease-out forwards;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
      }

      @keyframes floatUp {
        0% {
          opacity: 1;
          transform: translateY(0);
        }
        100% {
          opacity: 0;
          transform: translateY(-100px);
        }
      }
    </style>
  </head>
  <body>
    <div id="canvas-container"></div>

    <div id="ui-overlay">
      <h2 id="title"></h2>
      <p style="font-size: 20px" id="subtitle"></p>
      <p id="move-instruction"></p>
      <p id="look-instruction"></p>
      <p id="interact-instruction"></p>
      <p id="dance-instruction"></p>
      <p id="close-instruction"></p>
      <p class="instruction" style="margin-top: 10px" id="tip-instruction"></p>
    </div>

    <div id="dialogue-box">
      <h3 id="dialogue-name">Name</h3>
      <div id="dialogue-content">Content</div>
      <div id="dialogue-options"></div>
      <div id="custom-question-container">
        <p
          style="
            margin: 5px 0;
            font-size: 14px;
            opacity: 0.8;
            text-align: center;
          "
          id="custom-question-divider"
        ></p>
        <input type="text" id="custom-question-input" maxlength="200" />
        <button id="custom-question-submit"></button>
      </div>
    </div>

    <div id="interaction-prompt"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      // Translations
      const TRANSLATIONS = {
        "en-US": {
          title: "Xardent Team Office",
          subtitle: "ðŸŽ‰ Meet the Amazing Team",
          moveInstruction: "Use WASD to move around",
          lookInstruction: "Arrow keys or mouse to look left/right",
          interactInstruction: "Press E to interact",
          danceInstruction: "Press SPACE to dance",
          closeInstruction: "Press ESC to close dialogs/release mouse",
          tipInstruction: "ðŸ’¡ Type custom questions when talking!",
          customQuestionDivider: "â”â”â” Or ask your own question â”â”â”",
          customQuestionPlaceholder:
            "Ask anything! e.g., 'What's your favorite Claude feature?' or 'Do you dream of electric sheep?'",
          askQuestionButton: "Ask Question",
          pressEToTalk: "Press E to talk",
          pressEToTalkTo: "Press E to talk to",
          youLabel: "You:",
          danceEmoji: "ðŸ’ƒðŸ•º",
          musicEmoji: "ðŸŽµ",
          ideaEmoji: "ðŸ’¡",
          oofText: "Oof!",
          bonkText: "Bonk!",
          roleQuestion: "Tell me about your role at Xardent",
          typicalDayQuestion: "What's your typical workday like?",
          challengingPartQuestion: "What's the most fun part of your job?",
          officeDecisionQuestion: "How did you choose your desk spot?",
          excitingProjectQuestion: "What cool project are you working on?",
          breakthroughQuestion: "What's your proudest achievement?",
          claudeNextQuestion: "What's next for Xardent?",
          funnyRequestQuestion:
            "What's the funniest client request you've gotten?",
          safetyStartQuestion: "How did you get started in tech?",
          paperclipQuestion: "What's your favorite productivity hack?",
          concernQuestion: "What's your favorite tech stack?",
          surpriseQuestion: "What's the best part of working at Xardent?",
          alignmentChallengesQuestion: "What's your biggest work challenge?",
          anthropicApproachQuestion: "What makes Xardent special?",
          constitutionalAIQuestion: "What's your development philosophy?",
          edgeCaseQuestion: "What's the weirdest bug you've fixed?",
          activationFunctionQuestion:
            "What's your favorite programming language?",
          dreamGradientsQuestion: "Do you dream about code?",
          transformerNameQuestion: "What would you name your startup?",
          pEqualsNPQuestion: "iOS or Android?",
          coffeeBreaksQuestion: "Coffee or tea?",
          claudeDebugQuestion: "What's your debugging strategy?",
          computerJokeQuestion: "What's your favorite tech meme?",
          memesQuestion: "What's your go-to stress reliever?",
          imposterSyndromeQuestion: "What motivates you to code?",
          gitCommitQuestion: "What's your git commit style?",
          tabsSpacesQuestion: "Tabs or spaces?",
          bashrcQuestion: "What IDE do you use?",
          bugFixQuestion: "What's your favorite feature you've built?",
          darkLightModeQuestion: "Dark mode or light mode?",
          errorMessageQuestion: "What's the coolest tech you've learned?",
          responseInLanguage: "Please respond in",
        },
        /* LOCALE_PLACEHOLDER_START */
        "es-ES": {
          title: "Oficina del Equipo de Xardent",
          subtitle: "ðŸŽ‰ Conoce al Equipo IncreÃ­ble",
          moveInstruction: "Usa WASD para moverte",
          lookInstruction:
            "Teclas de direcciÃ³n o ratÃ³n para mirar izquierda/derecha",
          interactInstruction: "Presiona E para interactuar",
          danceInstruction: "Presiona ESPACIO para bailar",
          closeInstruction: "Presiona ESC para cerrar diÃ¡logos/liberar ratÃ³n",
          tipInstruction: "ðŸ’¡ Â¡Escribe preguntas personalizadas cuando hables!",
          customQuestionDivider: "â”â”â” O haz tu propia pregunta â”â”â”",
          customQuestionPlaceholder:
            "Â¡Pregunta lo que quieras! ej., 'Â¿CuÃ¡l es tu funciÃ³n favorita de Claude?' o 'Â¿SueÃ±as con ovejas elÃ©ctricas?'",
          askQuestionButton: "Hacer Pregunta",
          pressEToTalk: "Presiona E para hablar",
          pressEToTalkTo: "Presiona E para hablar con",
          youLabel: "TÃº:",
          danceEmoji: "ðŸ’ƒðŸ•º",
          musicEmoji: "ðŸŽµ",
          ideaEmoji: "ðŸ’¡",
          oofText: "Â¡Ay!",
          bonkText: "Â¡Golpe!",
          roleQuestion: "CuÃ©ntame sobre tu rol en Xardent",
          typicalDayQuestion: "Â¿CÃ³mo es tu dÃ­a laboral tÃ­pico?",
          challengingPartQuestion:
            "Â¿CuÃ¡l es la parte mÃ¡s divertida de tu trabajo?",
          officeDecisionQuestion: "Â¿CÃ³mo elegiste tu lugar de escritorio?",
          excitingProjectQuestion: "Â¿En quÃ© proyecto genial estÃ¡s trabajando?",
          breakthroughQuestion: "Â¿CuÃ¡l es tu logro mÃ¡s orgulloso?",
          claudeNextQuestion: "Â¿QuÃ© sigue para Xardent?",
          funnyRequestQuestion:
            "Â¿CuÃ¡l es la solicitud mÃ¡s graciosa de un cliente?",
          safetyStartQuestion: "Â¿CÃ³mo empezaste en tecnologÃ­a?",
          paperclipQuestion: "Â¿CuÃ¡l es tu hack de productividad favorito?",
          concernQuestion: "Â¿CuÃ¡l es tu stack tecnolÃ³gico favorito?",
          surpriseQuestion: "Â¿CuÃ¡l es la mejor parte de trabajar en Xardent?",
          alignmentChallengesQuestion: "Â¿CuÃ¡l es tu mayor desafÃ­o laboral?",
          anthropicApproachQuestion: "Â¿QuÃ© hace especial a Xardent?",
          constitutionalAIQuestion: "Â¿CuÃ¡l es tu filosofÃ­a de desarrollo?",
          edgeCaseQuestion: "Â¿CuÃ¡l es el error mÃ¡s extraÃ±o que has arreglado?",
          activationFunctionQuestion:
            "Â¿CuÃ¡l es tu lenguaje de programaciÃ³n favorito?",
          dreamGradientsQuestion: "Â¿SueÃ±as con cÃ³digo?",
          transformerNameQuestion: "Â¿CÃ³mo nombrarÃ­as tu startup?",
          pEqualsNPQuestion: "Â¿iOS o Android?",
          coffeeBreaksQuestion: "Â¿CafÃ© o tÃ©?",
          claudeDebugQuestion: "Â¿CuÃ¡l es tu estrategia de depuraciÃ³n?",
          computerJokeQuestion: "Â¿CuÃ¡l es tu meme tech favorito?",
          memesQuestion: "Â¿CuÃ¡l es tu forma de aliviar el estrÃ©s?",
          imposterSyndromeQuestion: "Â¿QuÃ© te motiva a programar?",
          gitCommitQuestion: "Â¿CuÃ¡l es tu estilo de commits de git?",
          tabsSpacesQuestion: "Â¿Tabulaciones o espacios?",
          bashrcQuestion: "Â¿QuÃ© IDE usas?",
          bugFixQuestion: "Â¿CuÃ¡l es tu funciÃ³n favorita que has construido?",
          darkLightModeQuestion: "Â¿Modo oscuro o claro?",
          errorMessageQuestion:
            "Â¿CuÃ¡l es la tecnologÃ­a mÃ¡s genial que has aprendido?",
          responseInLanguage: "Por favor responde en",
        },
        /* LOCALE_PLACEHOLDER_END */
      };

      // Language detection
      const appLocale = "{{APP_LOCALE}}";
      const browserLocale =
        navigator.languages?.[0] || navigator.language || "en-US";
      const findMatchingLocale = (locale) => {
        if (TRANSLATIONS[locale]) return locale;
        const lang = locale.split("-")[0];
        const match = Object.keys(TRANSLATIONS).find((key) =>
          key.startsWith(lang + "-")
        );
        return match || "en-US";
      };
      const locale =
        appLocale !== "{{APP_LOCALE}}"
          ? findMatchingLocale(appLocale)
          : findMatchingLocale(browserLocale);
      const t = (key) =>
        TRANSLATIONS[locale]?.[key] || TRANSLATIONS["en-US"][key] || key;

      // Update UI text
      document.getElementById("title").textContent = t("title");
      document.getElementById("subtitle").textContent = t("subtitle");
      document.getElementById("move-instruction").textContent =
        t("moveInstruction");
      document.getElementById("look-instruction").textContent =
        t("lookInstruction");
      document.getElementById("interact-instruction").textContent = t(
        "interactInstruction"
      );
      document.getElementById("dance-instruction").textContent =
        t("danceInstruction");
      document.getElementById("close-instruction").textContent =
        t("closeInstruction");
      document.getElementById("tip-instruction").textContent =
        t("tipInstruction");
      document.getElementById("custom-question-divider").textContent = t(
        "customQuestionDivider"
      );
      document.getElementById("custom-question-input").placeholder = t(
        "customQuestionPlaceholder"
      );
      document.getElementById("custom-question-submit").textContent =
        t("askQuestionButton");

      // Scene setup
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb); // Sky blue for happy vibes
      scene.fog = new THREE.Fog(0x87ceeb, 10, 50);

      const exteriorGroup = new THREE.Group();
      const interiorGroup = new THREE.Group();
      scene.add(exteriorGroup);
      scene.add(interiorGroup);
      interiorGroup.visible = false;

      let worldMode = "outside"; // 'outside' | 'inside'
      let nearbyDoor = false;
      let doorOpening = false;
      let doorOpenT = 0;

      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 1.6, 5);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document
        .getElementById("canvas-container")
        .appendChild(renderer.domElement);

      // Floating text effect
      function createFloatingText(text, worldPos) {
        const screenPos = worldPos.clone();
        screenPos.project(camera);

        const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;

        const div = document.createElement("div");
        div.className = "floating-text";
        div.textContent = text;
        div.style.left = x + "px";
        div.style.top = y + "px";
        document.body.appendChild(div);

        setTimeout(() => div.remove(), 2000);
      }

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
      directionalLight.position.set(10, 15, 10);
      directionalLight.castShadow = true;
      directionalLight.shadow.camera.near = 0.1;
      directionalLight.shadow.camera.far = 50;
      directionalLight.shadow.camera.left = -30;
      directionalLight.shadow.camera.right = 30;
      directionalLight.shadow.camera.top = 30;
      directionalLight.shadow.camera.bottom = -30;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      scene.add(directionalLight);

      // Exterior: ground + building + door
      const exteriorGround = new THREE.Mesh(
        new THREE.PlaneGeometry(120, 120),
        new THREE.MeshStandardMaterial({
          color: new THREE.Color(0xe5e7eb),
          roughness: 0.95,
        })
      );
      exteriorGround.rotation.x = -Math.PI / 2;
      exteriorGround.receiveShadow = true;
      exteriorGroup.add(exteriorGround);

      const buildingMaterial = new THREE.MeshStandardMaterial({
        color: new THREE.Color(0xf8fafc),
        roughness: 0.85,
        metalness: 0.02,
      });

      const building = new THREE.Mesh(
        new THREE.BoxGeometry(18, 10, 12),
        buildingMaterial
      );
      building.position.set(0, 5, -6);
      building.castShadow = true;
      building.receiveShadow = true;
      exteriorGroup.add(building);

      const glassMaterial = new THREE.MeshStandardMaterial({
        color: new THREE.Color(0x93c5fd),
        transparent: true,
        opacity: 0.22,
        roughness: 0.08,
        metalness: 0.25,
      });

      for (let x = -6; x <= 6; x += 6) {
        const windowPane = new THREE.Mesh(
          new THREE.PlaneGeometry(3.5, 2.2),
          glassMaterial
        );
        windowPane.position.set(x, 6.2, 0.15);
        windowPane.rotation.y = Math.PI;
        exteriorGroup.add(windowPane);
      }

      const doorFrame = new THREE.Mesh(
        new THREE.BoxGeometry(3.0, 5.0, 0.3),
        new THREE.MeshStandardMaterial({
          color: new THREE.Color(0x0f172a),
          roughness: 0.6,
          metalness: 0.2,
        })
      );
      doorFrame.position.set(0, 2.5, 0.1);
      exteriorGroup.add(doorFrame);

      const doorHinge = new THREE.Group();
      doorHinge.position.set(-1.35, 0, 0.28);
      const door = new THREE.Mesh(
        new THREE.BoxGeometry(2.7, 4.6, 0.18),
        new THREE.MeshStandardMaterial({
          color: new THREE.Color(0x1e293b),
          roughness: 0.35,
          metalness: 0.35,
        })
      );
      door.position.set(1.35, 2.3, 0);
      door.castShadow = true;
      door.receiveShadow = true;
      doorHinge.add(door);
      exteriorGroup.add(doorHinge);

      const signCanvas = document.createElement("canvas");
      signCanvas.width = 512;
      signCanvas.height = 128;
      const signCtx = signCanvas.getContext("2d");
      signCtx.fillStyle = "rgba(15, 23, 42, 0.92)";
      signCtx.fillRect(0, 0, signCanvas.width, signCanvas.height);
      signCtx.fillStyle = "#60a5fa";
      signCtx.font = "900 72px Arial";
      signCtx.textAlign = "center";
      signCtx.textBaseline = "middle";
      signCtx.fillText("XARDENT", 256, 66);
      const signTex = new THREE.CanvasTexture(signCanvas);
      const signPlane = new THREE.Mesh(
        new THREE.PlaneGeometry(10, 2.5),
        new THREE.MeshStandardMaterial({ map: signTex, transparent: true })
      );
      signPlane.position.set(0, 9.1, -0.05);
      signPlane.rotation.y = Math.PI;
      exteriorGroup.add(signPlane);

      // Floor with pattern
      const floorGeometry = new THREE.PlaneGeometry(40, 40);
      const floorMaterial = new THREE.MeshStandardMaterial({
        color: new THREE.Color(0xf1f5f9),
        roughness: 0.7,
        metalness: 0.1,
      });
      const floor = new THREE.Mesh(floorGeometry, floorMaterial);
      floor.rotation.x = -Math.PI / 2;
      floor.receiveShadow = true;
      interiorGroup.add(floor);

      // Add floor tiles pattern with rainbow colors
      const tileGeometry = new THREE.PlaneGeometry(2, 2);
      const tileColors = [0xe2e8f0, 0xf1f5f9, 0xe5e7eb, 0xf8fafc];

      for (let x = -20; x < 20; x += 2) {
        for (let z = -20; z < 20; z += 2) {
          const colorIndex =
            (Math.floor(x / 2) + Math.floor(z / 2)) % tileColors.length;
          const tileMaterial = new THREE.MeshStandardMaterial({
            color: new THREE.Color(tileColors[colorIndex]),
          });
          const tile = new THREE.Mesh(tileGeometry, tileMaterial);
          tile.position.set(x + 1, 0.01, z + 1);
          tile.rotation.x = -Math.PI / 2;
          tile.receiveShadow = true;
          interiorGroup.add(tile);
        }
      }

      // Walls with windows - more colorful!
      const wallMaterial = new THREE.MeshStandardMaterial({
        color: new THREE.Color(0xf8fafc),
        roughness: 0.9,
      });

      const windowMaterial = new THREE.MeshStandardMaterial({
        color: new THREE.Color(0x87ceeb),
        transparent: true,
        opacity: 0.3,
        roughness: 0.1,
        metalness: 0.5,
      });

      // Back wall with windows
      const backWall = new THREE.Mesh(
        new THREE.PlaneGeometry(40, 10),
        wallMaterial
      );
      backWall.position.set(0, 5, -20);
      backWall.receiveShadow = true;
      interiorGroup.add(backWall);

      // Add windows to back wall
      for (let x = -15; x <= 15; x += 10) {
        const window = new THREE.Mesh(
          new THREE.PlaneGeometry(4, 3),
          windowMaterial
        );
        window.position.set(x, 5, -19.9);
        interiorGroup.add(window);
      }

      // Side walls
      const leftWall = new THREE.Mesh(
        new THREE.PlaneGeometry(40, 10),
        wallMaterial
      );
      leftWall.position.set(-20, 5, 0);
      leftWall.rotation.y = Math.PI / 2;
      leftWall.receiveShadow = true;
      interiorGroup.add(leftWall);

      const rightWall = new THREE.Mesh(
        new THREE.PlaneGeometry(40, 10),
        wallMaterial
      );
      rightWall.position.set(20, 5, 0);
      rightWall.rotation.y = -Math.PI / 2;
      rightWall.receiveShadow = true;
      interiorGroup.add(rightWall);

      // Office furniture
      const woodMaterial = new THREE.MeshStandardMaterial({
        color: new THREE.Color(0x8b6914),
        roughness: 0.6,
        metalness: 0.1,
      });

      const metalMaterial = new THREE.MeshStandardMaterial({
        color: new THREE.Color(0x404040),
        roughness: 0.3,
        metalness: 0.8,
      });

      // Create detailed desks
      function createDesk(x, z) {
        const deskGroup = new THREE.Group();

        // Desk top
        const deskTop = new THREE.Mesh(
          new THREE.BoxGeometry(3, 0.1, 1.5),
          woodMaterial
        );
        deskTop.position.y = 0.75;
        deskTop.castShadow = true;
        deskTop.receiveShadow = true;
        deskGroup.add(deskTop);

        // Metal frame
        const frameGeometry = new THREE.BoxGeometry(0.05, 0.7, 0.05);
        const framePositions = [
          [-1.45, 0.35, -0.7],
          [1.45, 0.35, -0.7],
          [-1.45, 0.35, 0.7],
          [1.45, 0.35, 0.7],
        ];

        framePositions.forEach((pos) => {
          const frame = new THREE.Mesh(frameGeometry, metalMaterial);
          frame.position.set(...pos);
          frame.castShadow = true;
          deskGroup.add(frame);
        });

        // Computer monitor
        const monitorBase = new THREE.Mesh(
          new THREE.CylinderGeometry(0.15, 0.15, 0.05, 16),
          metalMaterial
        );
        monitorBase.position.set(0, 0.82, 0);
        deskGroup.add(monitorBase);

        const monitorStand = new THREE.Mesh(
          new THREE.BoxGeometry(0.05, 0.3, 0.05),
          metalMaterial
        );
        monitorStand.position.set(0, 0.95, 0);
        deskGroup.add(monitorStand);

        const monitorScreen = new THREE.Mesh(
          new THREE.BoxGeometry(1.2, 0.7, 0.05),
          new THREE.MeshStandardMaterial({
            color: new THREE.Color(0x000000),
            roughness: 0.1,
            metalness: 0.5,
          })
        );
        monitorScreen.position.set(0, 1.3, 0);
        deskGroup.add(monitorScreen);

        // Keyboard
        const keyboard = new THREE.Mesh(
          new THREE.BoxGeometry(0.4, 0.02, 0.15),
          metalMaterial
        );
        keyboard.position.set(0, 0.81, 0.3);
        deskGroup.add(keyboard);

        // Chair
        const chairSeat = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, 0.05, 0.5),
          new THREE.MeshStandardMaterial({ color: new THREE.Color(0x333333) })
        );
        chairSeat.position.set(0, 0.5, 0.8);
        deskGroup.add(chairSeat);

        const chairBack = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, 0.6, 0.05),
          new THREE.MeshStandardMaterial({ color: new THREE.Color(0x333333) })
        );
        chairBack.position.set(0, 0.8, 1.02);
        deskGroup.add(chairBack);

        // Random desk items
        if (Math.random() > 0.5) {
          // Coffee mug
          const mug = new THREE.Mesh(
            new THREE.CylinderGeometry(0.08, 0.08, 0.1, 8),
            new THREE.MeshStandardMaterial({ color: new THREE.Color(0xffffff) })
          );
          mug.position.set(
            Math.random() * 0.5 - 0.25,
            0.85,
            Math.random() * 0.3
          );
          deskGroup.add(mug);
        }

        deskGroup.position.set(x, 0, z);
        return deskGroup;
      }

      // Add desks for team members - arranged in clusters
      const desk1 = createDesk(-15, -10);
      const desk2 = createDesk(-5, -10);
      const desk3 = createDesk(5, -10);
      const desk4 = createDesk(15, -10);
      const desk5 = createDesk(-15, 0);
      const desk6 = createDesk(-5, 0);
      const desk7 = createDesk(5, 0);
      const desk8 = createDesk(15, 0);
      const desk9 = createDesk(-10, 8);
      const desk10 = createDesk(0, 8);
      const desk11 = createDesk(10, 8);
      const desk12 = createDesk(-10, -8);
      interiorGroup.add(
        desk1,
        desk2,
        desk3,
        desk4,
        desk5,
        desk6,
        desk7,
        desk8,
        desk9,
        desk10,
        desk11,
        desk12
      );

      // Add colorful XARDENT sign - positioned above whiteboard
      const letterColors = [
        0x2563eb, 0x2563eb, 0x2563eb, 0x2563eb, 0x2563eb, 0x2563eb, 0x2563eb,
      ];
      const letters = ["X", "A", "R", "D", "E", "N", "T"];

      letters.forEach((letter, index) => {
        const letterGeometry = new THREE.BoxGeometry(0.8, 1.5, 0.3);
        const letterMaterial = new THREE.MeshStandardMaterial({
          color: new THREE.Color(letterColors[index]),
          roughness: 0.3,
          metalness: 0.2,
        });
        const letterMesh = new THREE.Mesh(letterGeometry, letterMaterial);
        letterMesh.position.set((index - 3) * 1.2, 6, -19.5);
        letterMesh.castShadow = true;
        letterMesh.receiveShadow = true;
        interiorGroup.add(letterMesh);
      });

      // Add whiteboard
      const whiteboardMaterial = new THREE.MeshStandardMaterial({
        color: new THREE.Color(0xe6f3ff), // Light blue instead of plain white
        roughness: 0.2,
        metalness: 0.1,
      });

      const whiteboard = new THREE.Mesh(
        new THREE.BoxGeometry(4, 2, 0.1),
        whiteboardMaterial
      );
      whiteboard.position.set(0, 3, -19.8);
      whiteboard.castShadow = true;
      interiorGroup.add(whiteboard);

      // Happy Roomba with rainbow colors
      const roombaGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.1, 16);
      const roombaMaterial = new THREE.MeshStandardMaterial({
        color: new THREE.Color(0xff69b4),
      }); // Hot pink Roomba!
      const roomba = new THREE.Mesh(roombaGeometry, roombaMaterial);
      roomba.position.set(5, 0.05, 5);
      roomba.userData = { velocity: new THREE.Vector3(0.05, 0, 0.05) };
      roomba.castShadow = true;
      interiorGroup.add(roomba);

      // Add happy decorations - floating balloons!
      const balloonColors = [0xff6b6b, 0xffd93d, 0x6bcf7f, 0x4ecdc4, 0xff69b4];
      for (let i = 0; i < 10; i++) {
        const balloonGeometry = new THREE.SphereGeometry(0.4, 8, 8);
        const balloonMaterial = new THREE.MeshStandardMaterial({
          color: new THREE.Color(balloonColors[i % balloonColors.length]),
          roughness: 0.3,
          metalness: 0.1,
        });
        const balloon = new THREE.Mesh(balloonGeometry, balloonMaterial);

        // Random positions around the office
        balloon.position.set(
          Math.random() * 30 - 15,
          6 + Math.random() * 2,
          Math.random() * 30 - 15
        );
        balloon.castShadow = true;
        interiorGroup.add(balloon);

        // Add string
        const stringGeometry = new THREE.CylinderGeometry(0.02, 0.02, 3, 4);
        const stringMaterial = new THREE.MeshStandardMaterial({
          color: new THREE.Color(0x666666),
        });
        const string = new THREE.Mesh(stringGeometry, stringMaterial);
        string.position.copy(balloon.position);
        string.position.y -= 2;
        interiorGroup.add(string);
      }

      // Colorful plant decorations
      const plantPot = new THREE.Mesh(
        new THREE.CylinderGeometry(0.3, 0.25, 0.4, 8),
        new THREE.MeshStandardMaterial({ color: new THREE.Color(0xff6b6b) }) // Colorful red pot
      );
      plantPot.position.set(-15, 0.2, -15);
      plantPot.castShadow = true;
      interiorGroup.add(plantPot);

      const plantLeaves = new THREE.Mesh(
        new THREE.SphereGeometry(0.6, 6, 5),
        new THREE.MeshStandardMaterial({ color: new THREE.Color(0x32cd32) }) // Lime green leaves
      );
      plantLeaves.position.set(-15, 0.8, -15);
      plantLeaves.castShadow = true;
      interiorGroup.add(plantLeaves);

      // Add more colorful plants
      const plantPot2 = new THREE.Mesh(
        new THREE.CylinderGeometry(0.3, 0.25, 0.4, 8),
        new THREE.MeshStandardMaterial({ color: new THREE.Color(0xffd93d) }) // Yellow pot
      );
      plantPot2.position.set(15, 0.2, -15);
      plantPot2.castShadow = true;
      interiorGroup.add(plantPot2);

      const plantLeaves2 = new THREE.Mesh(
        new THREE.SphereGeometry(0.6, 6, 5),
        new THREE.MeshStandardMaterial({ color: new THREE.Color(0x00ff7f) }) // Spring green
      );
      plantLeaves2.position.set(15, 0.8, -15);
      plantLeaves2.castShadow = true;
      interiorGroup.add(plantLeaves2);

      const plantPot3 = new THREE.Mesh(
        new THREE.CylinderGeometry(0.3, 0.25, 0.4, 8),
        new THREE.MeshStandardMaterial({ color: new THREE.Color(0x9b59b6) }) // Purple pot
      );
      plantPot3.position.set(0, 0.2, 15);
      plantPot3.castShadow = true;
      interiorGroup.add(plantPot3);

      const plantLeaves3 = new THREE.Mesh(
        new THREE.SphereGeometry(0.6, 6, 5),
        new THREE.MeshStandardMaterial({ color: new THREE.Color(0x3cb371) }) // Medium sea green
      );
      plantLeaves3.position.set(0, 0.8, 15);
      plantLeaves3.castShadow = true;
      interiorGroup.add(plantLeaves3);

      // Add coffee station
      const coffeeTable = new THREE.Mesh(
        new THREE.BoxGeometry(2, 0.8, 1),
        woodMaterial
      );
      coffeeTable.position.set(-18, 0.4, 10);
      coffeeTable.castShadow = true;
      interiorGroup.add(coffeeTable);

      const coffeeMachine = new THREE.Mesh(
        new THREE.BoxGeometry(0.4, 0.5, 0.3),
        metalMaterial
      );
      coffeeMachine.position.set(-18, 1.05, 10);
      interiorGroup.add(coffeeMachine);

      // Character creation with more detail
      const characters = [];

      const chairSpots = [
        { x: -15, z: -9.2, ry: 0 },
        { x: -5, z: -9.2, ry: 0 },
        { x: 5, z: -9.2, ry: 0 },
        { x: 15, z: -9.2, ry: 0 },
        { x: -15, z: 0.8, ry: 0 },
        { x: -5, z: 0.8, ry: 0 },
        { x: 5, z: 0.8, ry: 0 },
        { x: 15, z: 0.8, ry: 0 },
        { x: -10, z: 8.8, ry: 0 },
        { x: 0, z: 8.8, ry: 0 },
        { x: 10, z: 8.8, ry: 0 },
        { x: -10, z: -7.2, ry: 0 },
      ];

      function createCharacter(name, role, x, z, shirtColor, characterData) {
        const group = new THREE.Group();
        const torsoGeometry = new THREE.CylinderGeometry(0.25, 0.3, 0.8, 8);
        const torsoMaterial = new THREE.MeshStandardMaterial({
          color: new THREE.Color(shirtColor),
        });
        const torso = new THREE.Mesh(torsoGeometry, torsoMaterial);
        torso.position.y = 0.6;
        torso.castShadow = true;
        group.add(torso);

        // Arms
        const armGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.6, 6);
        const armMaterial = new THREE.MeshStandardMaterial({
          color: new THREE.Color(shirtColor),
        });

        const leftArm = new THREE.Mesh(armGeometry, armMaterial);
        leftArm.position.set(-0.3, 0.7, 0);
        leftArm.rotation.z = Math.PI / 8;
        group.add(leftArm);

        const rightArm = new THREE.Mesh(armGeometry, armMaterial);
        rightArm.position.set(0.3, 0.7, 0);
        rightArm.rotation.z = -Math.PI / 8;
        group.add(rightArm);

        // Legs
        const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 6);
        const legMaterial = new THREE.MeshStandardMaterial({
          color: new THREE.Color(0x2c3e50),
        });

        const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
        leftLeg.position.set(-0.15, 0.4, 0);
        group.add(leftLeg);

        const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
        rightLeg.position.set(0.15, 0.4, 0);
        group.add(rightLeg);

        // Head
        const headGeometry = new THREE.SphereGeometry(0.25, 8, 6);
        const headMaterial = new THREE.MeshStandardMaterial({
          color: new THREE.Color(0xffdbac),
        });
        const head = new THREE.Mesh(headGeometry, headMaterial);
        head.position.y = 1.25;
        head.castShadow = true;
        group.add(head);

        // Hair
        const hairGeometry = new THREE.SphereGeometry(0.27, 8, 6);
        const hairMaterial = new THREE.MeshStandardMaterial({
          color: new THREE.Color(characterData.hairColor),
        });
        const hair = new THREE.Mesh(hairGeometry, hairMaterial);
        hair.position.y = 1.35;
        hair.scale.y = 0.6;
        group.add(hair);

        // Eyes
        const eyeGeometry = new THREE.SphereGeometry(0.03, 4, 4);
        const eyeMaterial = new THREE.MeshStandardMaterial({
          color: new THREE.Color(0x000000),
        });

        const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        leftEye.position.set(-0.08, 1.25, 0.22);
        group.add(leftEye);

        const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        rightEye.position.set(0.08, 1.25, 0.22);
        group.add(rightEye);

        // Name label
        const canvas = document.createElement("canvas");
        canvas.width = 256;
        canvas.height = 64;
        const context = canvas.getContext("2d");
        context.fillStyle = "rgba(255, 255, 255, 0.9)";
        context.fillRect(0, 0, 256, 64);
        context.fillStyle = "black";
        context.font = "bold 20px Arial";
        context.textAlign = "center";
        context.fillText(name, 128, 25);
        context.font = "16px Arial";
        context.fillStyle = "#666";
        context.fillText(role, 128, 45);

        const texture = new THREE.CanvasTexture(canvas);
        const labelMaterial = new THREE.SpriteMaterial({ map: texture });
        const label = new THREE.Sprite(labelMaterial);
        label.position.y = 1.8;
        label.scale.set(2, 0.5, 1);
        group.add(label);

        if (characterData?.seated) {
          torso.position.y = 0.95;
          leftArm.position.y = 1.05;
          rightArm.position.y = 1.05;

          leftLeg.rotation.x = Math.PI / 2;
          rightLeg.rotation.x = Math.PI / 2;
          leftLeg.position.set(-0.15, 0.55, 0.25);
          rightLeg.position.set(0.15, 0.55, 0.25);

          head.position.y = 1.6;
          hair.position.y = 1.7;
          leftEye.position.y = 1.6;
          rightEye.position.y = 1.6;
          label.position.y = 2.15;
        }

        group.position.set(x, 0, z);
        group.userData = {
          name,
          role,
          conversations: [],
          initialPosition: new THREE.Vector3(x, 0, z),
          targetPosition: new THREE.Vector3(x, 0, z),
          moveTimer: 0,
          isDancing: false,
          tripChance: 0.001,
          leftArm: leftArm,
          rightArm: rightArm,
          ...characterData,
        };

        characters.push(group);
        return group;
      }

      // Add Xardent team members
      const pravin = createCharacter(
        "Pravin",
        "Co-founder",
        chairSpots[0].x,
        chairSpots[0].z,
        0xff6b6b,
        {
          hairColor: 0x2d3436,
          personality: "visionary and energetic",
          quirk: "gets super excited about new ideas and talks really fast",
          seated: true,
        }
      );

      const sarthak = createCharacter(
        "Sarthak",
        "Co-founder",
        chairSpots[3].x,
        chairSpots[3].z,
        0x4ecdc4,
        {
          hairColor: 0x34495e,
          personality: "strategic and calm",
          quirk: "solves problems with zen-like patience",
          seated: true,
        }
      );

      const sahil = createCharacter(
        "Sahil",
        "Developer",
        chairSpots[4].x,
        chairSpots[4].z,
        0xf39c12,
        {
          hairColor: 0x5f3b23,
          personality: "coding ninja",
          quirk: "writes code so clean it sparkles",
          seated: true,
        }
      );

      const shivam = createCharacter(
        "Shivam",
        "Developer",
        chairSpots[5].x,
        chairSpots[5].z,
        0x9b59b6,
        {
          hairColor: 0x3e2723,
          personality: "bug destroyer",
          quirk: "debugs in their sleep",
          seated: true,
        }
      );

      const satish = createCharacter(
        "Satish",
        "Developer",
        chairSpots[6].x,
        chairSpots[6].z,
        0x3498db,
        {
          hairColor: 0x424242,
          personality: "algorithm wizard",
          quirk: "can optimize anything, even coffee breaks",
          seated: true,
        }
      );

      const sagar = createCharacter(
        "Sagar",
        "UI/UX Designer",
        chairSpots[8].x,
        chairSpots[8].z,
        0xe74c3c,
        {
          hairColor: 0x4a2c2a,
          personality: "pixel perfectionist",
          quirk: "sees design flaws in dreams",
          seated: true,
        }
      );

      const ridhima = createCharacter(
        "Ridhima",
        "UI/UX Designer",
        chairSpots[9].x,
        chairSpots[9].z,
        0xff69b4,
        {
          hairColor: 0x6a1b4d,
          personality: "color harmony master",
          quirk: "has a personal relationship with every shade of blue",
          seated: true,
        }
      );

      const antra = createCharacter(
        "Antra",
        "UI/UX Designer",
        chairSpots[10].x,
        chairSpots[10].z,
        0xffd93d,
        {
          hairColor: 0x4e342e,
          personality: "user experience guru",
          quirk: "A/B tests everything, including lunch options",
          seated: true,
        }
      );

      const om = createCharacter(
        "Om",
        "Flutter Developer",
        chairSpots[7].x,
        chairSpots[7].z,
        0x00d2ff,
        {
          hairColor: 0x1a1a1a,
          personality: "widget whisperer",
          quirk: "dreams in hot reload",
          seated: true,
        }
      );

      const vishal = createCharacter(
        "Vishal",
        "Flutter Developer",
        chairSpots[1].x,
        chairSpots[1].z,
        0x6bcf7f,
        {
          hairColor: 0x3d2817,
          personality: "state management master",
          quirk: "can build an app during a coffee break",
          seated: true,
        }
      );

      const amit = createCharacter(
        "Amit",
        "Management",
        chairSpots[2].x,
        chairSpots[2].z,
        0xff8c00,
        {
          hairColor: 0x2c2c2c,
          personality: "strategic thinker",
          quirk: "can turn chaos into organized success",
          seated: true,
        }
      );

      const ajay = createCharacter(
        "Ajay",
        "Management",
        chairSpots[11].x,
        chairSpots[11].z,
        0x20b2aa,
        {
          hairColor: 0x1a1a1a,
          personality: "people-focused leader",
          quirk: "knows everyone's coffee order by heart",
          seated: true,
        }
      );

      interiorGroup.add(
        pravin,
        sarthak,
        sahil,
        shivam,
        satish,
        sagar,
        ridhima,
        antra,
        om,
        vishal,
        amit,
        ajay
      );

      characters.forEach((c, idx) => {
        if (c.userData?.seated) {
          c.userData.tripChance = 0;
          c.userData.moveTimer = 999999;
          c.userData.targetPosition.copy(c.position);
          c.rotation.y = chairSpots[idx]?.ry ?? 0;
        }
      });

      // Get references to input elements early
      const customQuestionInput = document.getElementById(
        "custom-question-input"
      );
      const customQuestionSubmit = document.getElementById(
        "custom-question-submit"
      );

      // Player controls
      const player = {
        position: new THREE.Vector3(0, 1.6, 5),
        velocity: new THREE.Vector3(0, 0, 0),
        speed: 0.1,
        isDancing: false,
      };

      const keys = {};

      document.addEventListener("keydown", (e) => {
        // Don't process game controls if typing in the custom question input
        if (document.activeElement === customQuestionInput) {
          // Only process ESC when typing
          if (e.key === "Escape") {
            dialogueBox.style.display = "none";
            currentCharacter = null;
            if (document.pointerLockElement === renderer.domElement) {
              document.exitPointerLock();
            }
          }
          return;
        }

        keys[e.key.toLowerCase()] = true;
        keys[e.key] = true; // Store original key for arrow keys

        if (
          e.key.toLowerCase() === "e" &&
          worldMode === "outside" &&
          nearbyDoor &&
          !doorOpening
        ) {
          e.preventDefault();
          doorOpening = true;
          doorOpenT = 0;
        }

        if (
          e.key.toLowerCase() === "e" &&
          worldMode === "inside" &&
          nearbyCharacter &&
          dialogueBox.style.display !== "block"
        ) {
          e.preventDefault();
          openDialogue(nearbyCharacter);
        }

        if (e.key === " " && dialogueBox.style.display !== "block") {
          e.preventDefault();
          player.isDancing = true;
          createFloatingText(t("danceEmoji"), player.position);
        }

        // Prevent arrow keys from scrolling the page
        if (
          ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)
        ) {
          e.preventDefault();
        }
      });

      document.addEventListener("keyup", (e) => {
        // Don't process game controls if typing in the custom question input
        if (document.activeElement === customQuestionInput) {
          return;
        }

        keys[e.key.toLowerCase()] = false;
        keys[e.key] = false; // Clear original key for arrow keys

        if (e.key === " " && dialogueBox.style.display !== "block") {
          player.isDancing = false;
        }
      });

      // Character movement AI
      function updateCharacterMovement(character, deltaTime) {
        if (character.userData?.seated) return;
        // Random events
        if (
          Math.random() < character.userData.tripChance &&
          !character.userData.isDancing
        ) {
          // Character trips!
          character.rotation.x = Math.PI / 4;
          character.position.y = 0.3;
          createFloatingText(t("oofText"), character.position);

          setTimeout(() => {
            character.rotation.x = 0;
            character.position.y = 0;
          }, 1000);

          character.userData.tripChance = 0;
          setTimeout(() => {
            character.userData.tripChance = 0.001;
          }, 5000);
        }

        // Don't move if this character is in conversation or dancing
        if (character === currentCharacter || character.userData.isDancing) {
          if (character === currentCharacter) {
            // Face the player
            const lookTarget = new THREE.Vector3(
              player.position.x,
              character.position.y,
              player.position.z
            );
            character.lookAt(lookTarget);
            character.rotation.x = 0;
            character.rotation.z = 0;
          }
          return;
        }

        // Random dance party
        if (Math.random() < 0.001) {
          character.userData.isDancing = true;
          createFloatingText(t("musicEmoji"), character.position);
          setTimeout(() => {
            character.userData.isDancing = false;
          }, 3000);
        }

        character.userData.moveTimer -= deltaTime;

        if (character.userData.moveTimer <= 0) {
          // Set new random target
          const angle = Math.random() * Math.PI * 2;
          const distance = 3 + Math.random() * 5;
          character.userData.targetPosition = new THREE.Vector3(
            character.userData.initialPosition.x + Math.cos(angle) * distance,
            0,
            character.userData.initialPosition.z + Math.sin(angle) * distance
          );

          // Keep within bounds
          character.userData.targetPosition.x = Math.max(
            -18,
            Math.min(18, character.userData.targetPosition.x)
          );
          character.userData.targetPosition.z = Math.max(
            -18,
            Math.min(18, character.userData.targetPosition.z)
          );

          character.userData.moveTimer = 5 + Math.random() * 5;
        }

        // Move towards target
        const direction = new THREE.Vector3().subVectors(
          character.userData.targetPosition,
          character.position
        );
        direction.y = 0;
        const distance = direction.length();

        if (distance > 0.1) {
          direction.normalize();
          character.position.add(direction.multiplyScalar(0.02));

          // Face movement direction
          character.lookAt(character.userData.targetPosition);
          character.rotation.x = 0;
          character.rotation.z = 0;

          // Walking animation
          if (!character.userData.isDancing) {
            character.position.y =
              Math.abs(Math.sin(Date.now() * 0.005)) * 0.05;
          }
        }
      }

      // Dialogue system with humor
      const dialogueBox = document.getElementById("dialogue-box");
      const dialogueName = document.getElementById("dialogue-name");
      const dialogueContent = document.getElementById("dialogue-content");
      const dialogueOptions = document.getElementById("dialogue-options");
      const interactionPrompt = document.getElementById("interaction-prompt");

      let currentCharacter = null;
      let nearbyCharacter = null;

      function generateDialogueOptions(character) {
        // All possible questions
        const allQuestions = [
          // About their role
          t("roleQuestion"),
          t("typicalDayQuestion"),
          t("challengingPartQuestion"),
          t("officeDecisionQuestion"),

          // About projects
          t("excitingProjectQuestion"),
          t("breakthroughQuestion"),
          t("claudeNextQuestion"),
          t("funnyRequestQuestion"),

          // About AI safety
          t("safetyStartQuestion"),
          t("paperclipQuestion"),
          t("concernQuestion"),
          t("surpriseQuestion"),

          // About alignment
          t("alignmentChallengesQuestion"),
          t("anthropicApproachQuestion"),
          t("constitutionalAIQuestion"),
          t("edgeCaseQuestion"),

          // Fun technical questions
          t("activationFunctionQuestion"),
          t("dreamGradientsQuestion"),
          t("transformerNameQuestion"),
          t("pEqualsNPQuestion"),
          t("coffeeBreaksQuestion"),
          t("claudeDebugQuestion"),
          t("computerJokeQuestion"),
          t("memesQuestion"),
          t("imposterSyndromeQuestion"),

          // Quirky professional questions
          t("gitCommitQuestion"),
          t("tabsSpacesQuestion"),
          t("bashrcQuestion"),
          t("bugFixQuestion"),
          t("darkLightModeQuestion"),
          t("errorMessageQuestion"),
        ];

        // Select 4 random questions
        const shuffled = allQuestions.sort(() => Math.random() - 0.5);
        return shuffled.slice(0, 4);
      }

      function openDialogue(character) {
        currentCharacter = character;
        dialogueBox.style.display = "block";
        dialogueName.textContent = `${character.userData.name} - ${character.userData.role}`;

        // Exit pointer lock when opening dialogue
        if (document.pointerLockElement === renderer.domElement) {
          document.exitPointerLock();
        }

        const greetings = [
          `Hello! I'm ${character.userData.name}, ${character.userData.role} here at Anthropic. Ask me anything!`,
          `Oh hey! I'm ${character.userData.name}. Just ${character.userData.quirk}, as usual.`,
          `Hi there! ${character.userData.name} here. What can I help you understand about our work?`,
          `Great to meet you! I'm ${character.userData.name}. Fair warning: I ${character.userData.quirk}.`,
        ];

        if (character.userData.conversations.length === 0) {
          dialogueContent.innerHTML = `<p><strong>${
            character.userData.name
          }:</strong> ${
            greetings[Math.floor(Math.random() * greetings.length)]
          }</p>`;
        } else {
          // Show last exchange
          const lastConv =
            character.userData.conversations[
              character.userData.conversations.length - 1
            ];
          dialogueContent.innerHTML = `<p><strong>${t("youLabel")}</strong> ${
            lastConv.user
          }</p><p><strong>${character.userData.name}:</strong> ${
            lastConv.response
          }</p>`;
        }

        // Generate dialogue options
        const options = generateDialogueOptions(character);
        dialogueOptions.innerHTML = "";

        options.forEach((option) => {
          const optionDiv = document.createElement("div");
          optionDiv.className = "dialogue-option";
          optionDiv.textContent = option;
          optionDiv.onclick = () => selectOption(option);
          dialogueOptions.appendChild(optionDiv);
        });

        // Clear custom question input
        document.getElementById("custom-question-input").value = "";

        // Focus the input for easy typing
        setTimeout(() => {
          document.getElementById("custom-question-input").focus();
        }, 100);
      }

      async function selectOption(option) {
        if (!currentCharacter) return;

        // Show selected option
        dialogueContent.innerHTML += `<p><strong>${t(
          "youLabel"
        )}</strong> ${option}</p>`;
        dialogueContent.innerHTML += `<p><strong>${currentCharacter.userData.name}:</strong> <span class="loading"></span></p>`;

        // Scroll to bottom of dialogue
        dialogueContent.scrollTop = dialogueContent.scrollHeight;

        // Get references to custom question elements
        const customQuestionInput = document.getElementById(
          "custom-question-input"
        );
        const customQuestionSubmit = document.getElementById(
          "custom-question-submit"
        );

        // Disable options during loading
        dialogueOptions.style.pointerEvents = "none";
        dialogueOptions.style.opacity = "0.5";
        customQuestionInput.disabled = true;
        customQuestionSubmit.disabled = true;

        let responseText = "";

        // Try to use Claude API, but have fallback responses
        try {
          // Simpler prompt for more reliable JSON parsing
          const prompt = `You are roleplaying as ${
            currentCharacter.userData.name
          }, ${currentCharacter.userData.role} at Xardent.
Character traits: ${currentCharacter.userData.personality}, ${
            currentCharacter.userData.quirk
          }
User question: "${option}"

Important context: You work at Xardent, a tech company. Talk about app development, design, Flutter, coding, teamwork, or your specific role. Be enthusiastic and fun! Use emojis occasionally. Keep it light and happy!

${
  option.length > 50
    ? "This is a custom question from the user, so be creative and stay in character!"
    : ""
}

Respond as this character with clever wit and tech humor in 50-80 words.

${t("responseInLanguage")} ${locale} language.

IMPORTANT: Output ONLY valid JSON:
{"response": "your character's response here"}`;

          const response = await window.claude.complete(prompt);

          try {
            const data = JSON.parse(response);
            responseText = data.response;
          } catch (parseError) {
            console.warn("JSON parsing failed, using fallback responses");
            responseText = generateFallbackResponse(currentCharacter, option);
          }
        } catch (error) {
          console.error("API Error:", error);
          responseText = generateFallbackResponse(currentCharacter, option);
        }

        // Update conversation
        currentCharacter.userData.conversations.push({
          user: option,
          response: responseText,
        });

        // Update display
        dialogueContent.innerHTML = dialogueContent.innerHTML.replace(
          '<span class="loading"></span>',
          responseText
        );

        // Scroll to bottom
        dialogueContent.scrollTop = dialogueContent.scrollHeight;

        // Random dialogue events
        if (Math.random() < 0.2) {
          createFloatingText(t("ideaEmoji"), currentCharacter.position);
        }

        // Generate new options
        const newOptions = generateDialogueOptions(currentCharacter);
        dialogueOptions.innerHTML = "";

        newOptions.forEach((opt) => {
          const optionDiv = document.createElement("div");
          optionDiv.className = "dialogue-option";
          optionDiv.textContent = opt;
          optionDiv.onclick = () => selectOption(opt);
          dialogueOptions.appendChild(optionDiv);
        });

        // Re-enable options
        dialogueOptions.style.pointerEvents = "auto";
        dialogueOptions.style.opacity = "1";
        customQuestionInput.disabled = false;
        customQuestionSubmit.disabled = false;
        customQuestionInput.focus();
      }

      // Fallback response generator for Xardent team
      function generateFallbackResponse(character, question) {
        const responses = {
          Pravin: {
            role: [
              "As co-founder, I'm all about turning wild ideas into reality! Every day is a new adventure. Sometimes I talk so fast even I can't keep up! ðŸ˜„",
              "Co-founding Xardent has been incredible! I get excited about literally everything - new features, new clients, new coffee flavors!",
            ],
            project: [
              "We're building something amazing! I could talk about it for hours but I'll try to keep it short... okay maybe not that short! ðŸš€",
              "Our latest project is SO cool! *gets visibly more energetic* Want me to show you seventeen different features?",
            ],
            default: [
              "That's an awesome question! *speaks faster with excitement* We're doing some really innovative stuff here!",
              "Oh man, where do I even start?! This is going to be GREAT! âš¡",
              "Yes! I love this question! Let me tell you ALL about it! *takes deep breath*",
            ],
          },
          Sarthak: {
            role: [
              "As co-founder, I bring calm strategic thinking to balance out Pravin's amazing energy. Someone has to be zen around here! ðŸ§˜",
              "Co-founder and chief problem solver. I believe every challenge is just a puzzle waiting to be solved with patience.",
            ],
            project: [
              "We're taking a measured approach to innovation. Fast enough to compete, slow enough to do it right. That's the Xardent way.",
              "Currently working on some really thoughtful solutions. Rome wasn't built in a day, but we're building it better! ðŸ›ï¸",
            ],
            default: [
              "Interesting question! Let me think about this calmly and give you a thorough answer...",
              "Great question. The answer requires both patience and precision - two things I love!",
              "That's worth considering carefully. Here's my thoughtful take on it...",
            ],
          },
          Sahil: {
            role: [
              "I'm a developer here, and I write the cleanest code you've ever seen! Seriously, my functions are works of art. ðŸŽ¨",
              "Developer extraordinaire! My code is so clean, it makes other code jealous. True story!",
            ],
            project: [
              "Working on some really elegant solutions. Every line of code tells a story, and mine are bestsellers! ðŸ“š",
              "Building features that make users say 'wow!' My code? Spotless. My desk? ...let's not talk about that.",
            ],
            default: [
              "As a developer, I approach this with clean, elegant logic. Just like my code!",
              "That's a great question! Let me refactor my thoughts and give you the optimized answer...",
              "Interesting! My code would handle this beautifully. Want to see? Actually, it's 500 lines, maybe not...",
            ],
          },
          Shivam: {
            role: [
              "I'm the developer who makes bugs extinct! I actually debug in my sleep. My dreams are all console logs. ðŸ›",
              "Developer and professional bug hunter! They call me the Terminator... of bugs. No bug is safe!",
            ],
            project: [
              "Crushing bugs and building features! Last night I dreamed I was stuck in an infinite loop. Took me forever to wake up! ðŸ˜…",
              "Working on making our app bulletproof! Every edge case? Covered. Every bug? Destroyed!",
            ],
            default: [
              "Ha! That reminds me of a bug I squashed last week! Actually, it reminds me of seventeen bugs...",
              "Great question! No bugs in THIS answer, I promise! I've debugged it thoroughly.",
              "Interesting! My debugging senses are tingling... but in a good way!",
            ],
          },
          Satish: {
            role: [
              "I'm a developer who optimizes everything! I even optimized my morning routine - now I get 3 extra minutes of sleep! â±ï¸",
              "Developer and algorithm wizard! I can make any code faster, even my coffee-making algorithm!",
            ],
            project: [
              "Currently optimizing our core features. This algorithm used to take 5 seconds, now it takes 0.3! I'm basically a magician. ðŸª„",
              "Building systems that run FAST! My code is so optimized, it finishes before it starts. (Okay, not really, but almost!)",
            ],
            default: [
              "Let me optimize this answer for you! The time complexity is O(awesome). âœ¨",
              "Great question! I can answer this in log(n) time. That's developer humor!",
              "Interesting! My optimized answer is: *speaks incredibly efficiently*",
            ],
          },
          Sagar: {
            role: [
              "I'm a UI/UX designer, and I see design flaws EVERYWHERE! Even in my dreams. Last night a button wasn't centered. It was traumatic. ðŸ˜±",
              "Designer here! I'm basically a pixel perfectionist. That icon is 1px off and it's keeping me up at night!",
            ],
            project: [
              "Designing interfaces that users actually love! Every pixel matters. EVERY. SINGLE. PIXEL. ðŸŽ¯",
              "Creating beautiful, functional designs! My Figma files are organized like a royal library!",
            ],
            default: [
              "From a design perspective, this needs perfect alignment! Just like every element I design!",
              "Great question! Let me visualize this... *adjusts imaginary pixels in the air*",
              "Interesting! Is it just me or should this conversation be 2px to the left? Sorry, occupational hazard!",
            ],
          },
          Ridhima: {
            role: [
              "UI/UX designer and color harmony master! I have feelings about every shade of blue. Don't get me started on #0077B5! ðŸŽ¨",
              "Designer with a deep emotional connection to colors! Cerulean and azure had a fight in my dream last night!",
            ],
            project: [
              "Creating color schemes that make users smile! This gradient took me 3 hours but look how PERFECT it is! ðŸŒˆ",
              "Designing experiences with the perfect color palette! Every hue has been carefully selected with love!",
            ],
            default: [
              "Ooh, that question gives me navy blue vibes! Or maybe midnight blue? Let's discuss! ðŸ’™",
              "Great question! The answer should be in #FF6B6B because it's warm and friendly!",
              "Interesting! This conversation has strong teal energy. I can explain why for 20 minutes!",
            ],
          },
          Antra: {
            role: [
              "I'm a UI/UX designer who A/B tests EVERYTHING! I tested 7 different lunch options today. Sandwich won with 65% confidence! ðŸ¥ª",
              "User experience guru! I measure user satisfaction in my sleep. Actually, I track my dream quality too!",
            ],
            project: [
              "Designing experiences backed by DATA! This button got 23% more clicks when we moved it 5px. SCIENCE! ðŸ“Š",
              "Creating intuitive interfaces! I tested 47 variations of this feature. Users loved version 32!",
            ],
            default: [
              "Statistically speaking, this is a great question! Let me run a quick mental A/B test...",
              "Great question! According to my user research (sample size: everyone I asked), this is important!",
              "Interesting! I'd need to A/B test my response but preliminary data suggests it's good!",
            ],
          },
          Om: {
            role: [
              "Flutter developer here! I dream in hot reload. My nightmares are build errors. My dreams are smooth 60fps animations! ðŸ“±",
              "I build Flutter apps and honestly, hot reload is the best thing that ever happened to coding! Instant gratification!",
            ],
            project: [
              "Building cross-platform apps that just WORK! iOS? Check. Android? Check. Beautiful UI? Double check! âœ…",
              "Creating Flutter widgets like an artist! This animation is so smooth, butter is jealous!",
            ],
            default: [
              "As a Flutter dev, I can hot reload this answer if you don't like it! Just kidding... or am I? ðŸ”¥",
              "Great question! Let me build a widget for this answer... done! Flutter is FAST!",
              "Interesting! My Flutter instincts say this needs a Stateful widget. Everything needs stateful widgets!",
            ],
          },
          Vishal: {
            role: [
              "Flutter developer and state management master! I can build an app during a coffee break. Literally did it last Tuesday! â˜•",
              "I code in Flutter and manage state like a boss! Provider? Riverpod? Bloc? I speak all the languages!",
            ],
            project: [
              "Building apps at lightning speed! Yesterday I built a complete feature while waiting for my lunch to heat up! âš¡",
              "Creating Flutter magic! My widgets are so well-structured, they organize themselves!",
            ],
            default: [
              "Let me manage the state of this conversation! *uses Riverpod in real life* ðŸŽ¯",
              "Great question! I could build an app to answer this, but I'll just tell you instead!",
              "Interesting! This needs proper state management. Everything needs proper state management!",
            ],
          },
          Amit: {
            role: [
              "I'm in Management, turning chaos into organized success! Some call it magic, I call it strategic thinking! ðŸŽ¯",
              "Management team member here! I love taking messy situations and making them beautifully organized!",
            ],
            project: [
              "Coordinating our amazing team! It's like conducting an orchestra, except everyone plays a different instrument... and half are coding. ðŸŽ¼",
              "Managing projects and keeping everyone aligned! My superpower is seeing the big picture while handling the tiny details!",
            ],
            default: [
              "Great question! Let me organize my thoughts... *pulls out mental Kanban board* ðŸ“‹",
              "Interesting! From a management perspective, this requires both strategy and flexibility!",
              "That's a good one! I approach this like any project - break it down, prioritize, execute! âœ…",
            ],
          },
          Ajay: {
            role: [
              "I'm in Management and I know everyone's coffee order by heart! Leadership is about caring for your team! â˜•",
              "Management team member! I believe great teams are built on trust, communication, and knowing who needs extra sugar in their coffee!",
            ],
            project: [
              "Building a happy, productive team! My secret? Listen more than you talk and always remember birthdays! ðŸŽ‚",
              "Managing people and projects with empathy! The best solutions come from understanding everyone's perspective!",
            ],
            default: [
              "Great question! Let me think about this from everyone's point of view... ðŸ¤”",
              "Interesting! You know, this reminds me of what Sagar was saying yesterday... we should collaborate on this!",
              "That's important! In management, we always consider the human element first. People over processes! ðŸ‘¥",
            ],
          },
          default: {
            default: [
              "That's such a great question! Working at Xardent is amazing! ðŸŽ‰",
              "Love this question! We're building some really cool stuff here!",
              "Interesting! Let me tell you about how awesome Xardent is! ðŸš€",
              "Great question! The answer involves passion, teamwork, and probably coffee! â˜•",
            ],
          },
        };

        let responseKey = "default";
        const questionLower = question.toLowerCase();

        if (
          questionLower.includes("role") ||
          questionLower.includes("job") ||
          questionLower.includes("day")
        )
          responseKey = "role";
        else if (
          questionLower.includes("project") ||
          questionLower.includes("working") ||
          questionLower.includes("cool")
        )
          responseKey = "project";

        const characterResponses =
          responses[character.userData.name] || responses["default"];
        const responseArray =
          characterResponses[responseKey] ||
          characterResponses["default"] ||
          responses["default"]["default"];

        return responseArray[Math.floor(Math.random() * responseArray.length)];
      }

      // Close dialogue with Escape
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          dialogueBox.style.display = "none";
          currentCharacter = null;
          // Also exit pointer lock if active
          if (document.pointerLockElement === renderer.domElement) {
            document.exitPointerLock();
          }
        }
      });

      // Set up custom question handlers (elements already declared above)

      customQuestionSubmit.addEventListener("click", () => {
        const customQuestion = customQuestionInput.value.trim();
        if (customQuestion && currentCharacter) {
          selectOption(customQuestion);
          customQuestionInput.value = "";
        }
      });

      customQuestionInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          const customQuestion = customQuestionInput.value.trim();
          if (customQuestion && currentCharacter) {
            selectOption(customQuestion);
            customQuestionInput.value = "";
          }
        }
      });

      // Animation loop
      let lastTime = 0;

      function animate(currentTime) {
        requestAnimationFrame(animate);

        const deltaTime = (currentTime - lastTime) / 1000;
        lastTime = currentTime;

        // Update player movement (only if dialogue is not open)
        player.velocity.set(0, 0, 0);

        if (!player.isDancing && dialogueBox.style.display !== "block") {
          if (keys["w"]) player.velocity.z = player.speed;
          if (keys["s"]) player.velocity.z = -player.speed;
          if (keys["a"]) player.velocity.x = -player.speed;
          if (keys["d"]) player.velocity.x = player.speed;
        }

        // Arrow key camera controls (left/right only, disabled during dialogue)
        const lookSpeed = 0.05;
        if (dialogueBox.style.display !== "block") {
          if (keys["ArrowLeft"]) {
            mouseX += lookSpeed; // Changed from -= to +=
          }
          if (keys["ArrowRight"]) {
            mouseX -= lookSpeed; // Changed from += to -=
          }
        }

        // Update camera rotation based on mouse/arrow inputs (horizontal only, disabled during dialogue)
        if (!player.isDancing && dialogueBox.style.display !== "block") {
          camera.rotation.y = mouseX;
          camera.rotation.x = 0; // Keep looking straight ahead
        }

        // Apply movement in camera direction
        const forward = new THREE.Vector3(0, 0, -1);
        forward.applyQuaternion(camera.quaternion);
        forward.y = 0;
        forward.normalize();

        const right = new THREE.Vector3(1, 0, 0);
        right.applyQuaternion(camera.quaternion);
        right.y = 0;
        right.normalize();

        player.position.add(forward.multiplyScalar(player.velocity.z));
        player.position.add(right.multiplyScalar(player.velocity.x));

        // Keep player in bounds
        if (worldMode === "inside") {
          player.position.x = Math.max(-18, Math.min(18, player.position.x));
          player.position.z = Math.max(-18, Math.min(18, player.position.z));
        } else {
          player.position.x = Math.max(-45, Math.min(45, player.position.x));
          player.position.z = Math.max(-5, Math.min(55, player.position.z));
        }

        if (doorOpening) {
          doorOpenT = Math.min(1, doorOpenT + deltaTime * 1.25);
          doorHinge.rotation.y = -doorOpenT * (Math.PI / 2);
          if (doorOpenT >= 1) {
            worldMode = "inside";
            exteriorGroup.visible = false;
            interiorGroup.visible = true;
            player.position.set(0, 1.6, 5);
            mouseX = 0;
            doorOpening = false;
          }
        }

        // Dancing animation for player (disabled during dialogue)
        if (player.isDancing && dialogueBox.style.display !== "block") {
          camera.position.y =
            player.position.y + Math.sin(Date.now() * 0.01) * 0.2;
          camera.rotation.z = Math.sin(Date.now() * 0.01) * 0.1;
          // Still apply look rotation while dancing (horizontal only)
          camera.rotation.y = mouseX;
          camera.rotation.x = 0; // Keep looking straight ahead
        } else {
          camera.position.copy(player.position);
          camera.rotation.z = 0;
          if (dialogueBox.style.display !== "block") {
            camera.rotation.y = mouseX;
            camera.rotation.x = 0; // Keep looking straight ahead
          }
        }

        // Update character movement
        characters.forEach((character) => {
          updateCharacterMovement(character, deltaTime);

          // Dancing animation
          if (character.userData.isDancing) {
            character.rotation.y += 0.1;
            character.position.y = Math.abs(Math.sin(Date.now() * 0.01)) * 0.3;

            // Arm waving
            character.userData.leftArm.rotation.z =
              Math.sin(Date.now() * 0.01) * 0.5 + Math.PI / 8;
            character.userData.rightArm.rotation.z =
              -Math.sin(Date.now() * 0.01) * 0.5 - Math.PI / 8;
          }
        });

        // Update Roomba
        roomba.rotation.y += 0.05;
        roomba.position.add(roomba.userData.velocity);

        // Roomba collision detection
        if (
          Math.abs(roomba.position.x) > 18 ||
          Math.abs(roomba.position.z) > 18
        ) {
          roomba.userData.velocity.multiplyScalar(-1);
          createFloatingText(t("bonkText"), roomba.position);
        }

        // Check for nearby characters
        nearbyCharacter = null;
        let minDistance = Infinity;

        characters.forEach((character) => {
          const distance = player.position.distanceTo(character.position);
          if (distance < 3 && distance < minDistance) {
            minDistance = distance;
            nearbyCharacter = character;
          }
        });

        nearbyDoor = false;
        if (worldMode === "outside") {
          const doorPos = new THREE.Vector3();
          door.getWorldPosition(doorPos);
          nearbyDoor = player.position.distanceTo(doorPos) < 4.5;
        }

        // Show/hide interaction prompt (only when dialogue is not open)
        if (worldMode === "outside" && nearbyDoor && !currentCharacter) {
          interactionPrompt.style.display = "block";
          interactionPrompt.textContent = "Press E to open the door";
        } else if (
          worldMode === "inside" &&
          nearbyCharacter &&
          !currentCharacter
        ) {
          interactionPrompt.style.display = "block";
          interactionPrompt.textContent = `${t("pressEToTalkTo")} ${
            nearbyCharacter.userData.name
          }`;
        } else {
          interactionPrompt.style.display = "none";
        }

        renderer.render(scene, camera);
      }

      // Handle window resize
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Mouse look (horizontal only)
      let mouseX = 0;
      let mouseY = 0; // Not used but kept for code stability

      document.addEventListener("mousemove", (e) => {
        if (
          document.pointerLockElement === renderer.domElement &&
          dialogueBox.style.display !== "block"
        ) {
          mouseX += e.movementX * 0.002;
          // Vertical mouse movement disabled - only horizontal rotation allowed
        }
      });

      renderer.domElement.addEventListener("click", () => {
        if (
          !dialogueBox.style.display ||
          dialogueBox.style.display === "none"
        ) {
          renderer.domElement.requestPointerLock();
        }
      });

      animate(0);
    </script>
  </body>
</html>
